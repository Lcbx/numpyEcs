
in vec3 vertexPosition;
in vec2 vertexTexCoord;
in vec3 vertexNormal;
in vec4 vertexColor;

uniform mat4 mvp;

void vertex(){
	fragTexCoord = vertexTexCoord;
	vec4 vertex = vec4(vertexPosition, 1);
	vertex = mvp*vertex;
	gl_Position = vertex;
}

varying vec2 fragTexCoord;

uniform float projScale; // projection scale
//uniform mat4 proj; // projection
uniform mat4 invProj; // inverse proj matrix
uniform sampler2D texture0;	// normals
uniform sampler2D DepthMap;	// depth

const int NUM_SAMPLES = 16;
const int NUM_SPIRAL_TURNS = 8;
const int VARIATION = 1;

const float PI =  3.141593;
const float twoPI = 6.283186;
const float epsilon = 0.01;

const float radiusWS = 0.5;
const float radiusWS2 = radiusWS * radiusWS;
const float bias = 0.01;
const float intensity = 1;

out vec4 finalColor;

float random(vec2 co) {
	return fract(dot(co, vec2(2,11)) * dot(co.yx, vec2(7,5)) * 0.009);
}

vec3 getPositionVS(vec2 uv) {
	float z = texture(DepthMap, uv).r;
	vec3 clip = vec3(uv,z)*2.0 - vec3(1.0);
	vec4 view = invProj * vec4(clip, 1);
	return view.xyz / view.w;
}

float sampleAO(float vv, float vn)
{
	if(VARIATION == 0){ // (from the HPG12 paper)
		return float(vv < radiusWS2) * max(vn / (epsilon + vv), 0.0);
	}
	
	if(VARIATION == 1){ // default / recommended
		float f = max(radiusWS2 - vv, 0.0) / radiusWS2;
		return f * f * f * max(vn / (epsilon + vv), 0.0);
	}
	
	if(VARIATION == 2){
		float invRadius2 = 1.0 / radiusWS2;
		return 4.0 * max(1.0 - vv * invRadius2, 0.0) * max(vn, 0.0);
	}
	return 2.0 * float(vv < radiusWS2) * max(vn, 0.0);
}


void fragment() {
	
	// doubling uv so it covers the whole screen
	vec2 uv = fragTexCoord; //* 2.0;
	
	vec3 position = getPositionVS(uv);
	vec3 normal = normalize(texture(texture0, uv).xyz * 2.0 - vec3(1));
	
	float noise = random(gl_FragCoord.xy);
	
	float invSamples = 1.0 / float(NUM_SAMPLES);
	vec2 invTexSize = 1.0 / textureSize(DepthMap, 0);
	float invLenPos = 1.0 / length(position);
	float invPosY = 1.0 / abs(position.y);
	float invPosZ = 1.0 / abs(position.z);
	//float projScale = proj[1][1];
	
	float occlusion = 0.0;
	for (int sampleNumber = 0; sampleNumber < NUM_SAMPLES; ++sampleNumber) {
		float alpha = (float(sampleNumber) + 0.5) * invSamples;
		float angle = (alpha * float(NUM_SPIRAL_TURNS) + noise) * twoPI;
		vec2 disk = vec2(cos(angle), sin(angle)) * alpha;
		vec2 uv2 = uv + disk * radiusWS * projScale * invTexSize;
		uv2 = clamp(uv2, 0.0, 1.0);
		
		vec3 Q = getPositionVS(uv2);
		vec3 v = Q - position;
		
		float vv = dot(v, v);
		float vn = dot(v, normal) - bias;
		occlusion += sampleAO(vv, vn);
	}
	
	occlusion = occlusion * invSamples;
	occlusion = 1.0 - occlusion;
	occlusion = pow(occlusion, intensity);
	occlusion = clamp(occlusion, 0.0, 1.0);
	
	finalColor = vec4(vec3(occlusion), 1);
	//finalColor = vec4( (vec3(occlusion) + normal) * 0.7, 1);
	//finalColor = vec4(normal * 0.5 + 0.5, 1);
	//finalColor = vec4(position*0.05 + 0.5,1);
	//finalColor = vec4(fragTexCoord, 1, 1);
	//finalColor = vec4(gl_FragCoord.xy/textureSize(DepthMap, 0), 1, 1);
	//finalColor = vec4(1);
}
