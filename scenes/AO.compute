
in vec3 vertexPosition;
in vec2 vertexTexCoord;
in vec3 vertexNormal;
in vec4 vertexColor;

uniform mat4 mvp;

void vertex(){
	fragTexCoord = vertexTexCoord;
	vec4 vertex = vec4(vertexPosition, 1);
	vertex = mvp*vertex;
	gl_Position = vertex;
}

varying vec2 fragTexCoord;

uniform mat4 invProj; // inverse proj matrix
uniform sampler2D texture0;	// normals
uniform sampler2D DepthMap;	// depth

const int NUM_SAMPLES = 4;
const int NUM_SPIRAL_TURNS = NUM_SAMPLES/2 + 1;

const float PI =  3.141593;
const float twoPI = 6.283186;

const float radiusWS = 0.45;
const float radiusWS2 = radiusWS * radiusWS;
const float invRadius2 = 1.0 / radiusWS2;
const float bias = 0.1;
const float intensity = 2.5;

out vec4 finalColor;

float random(vec2 co) {
	return fract(dot(co.xy, vec2(3,13)) * dot(co.yx, vec2(7,4)) * 0.008);
}

float randAngle()
{
	uint x = uint(gl_FragCoord.x);
	uint y = uint(gl_FragCoord.y);
	return (30u * x ^ y + 10u * x * y);
}

vec3 getPositionVS(vec2 uv, int mip_level) {
	float z = textureLod(DepthMap, uv, mip_level).x;
	vec3 clip = vec3(uv,z)*2.0 - vec3(1.0);
	vec4 view = invProj * vec4(clip, 1);
	return view.xyz / view.w;
}

vec3 getPositionVS_px(ivec2 px, int mip_level) {
	float z = texelFetch(DepthMap, px, mip_level).x;
	vec3 clip = vec3(vec2(px)/textureSize(DepthMap, mip_level),z)*2.0 - vec3(1.0);
	vec4 view = invProj * vec4(clip, 1);
	return view.xyz / view.w;
}


// different AO formulas
float calculateAO(float vv, float vn)
{
	const float epsilon = 0.001;
	
	// (from the HPG12 paper)
	//return float(vv < radiusWS2) * max(vn / (epsilon + vv), 0.0);
	
	// default / recommended
	//float f = max(radiusWS2 - vv, 0.0) / radiusWS2;
	//return f * f * f * max(vn / (epsilon + vv), 0.0);
	
	return max(1.0 - vv * invRadius2, 0.0) * max(vn, 0.0);
	
	//return float(vv < radiusWS2) * max(vn, 0.0);
}


// TODO: apply normal-based blur

void fragment() {
	
	vec2 uv = fragTexCoord;
	// doubling uv so it covers the whole screen
	//uv *= 2.0;
	
	vec3 position = getPositionVS(uv, 0);
	vec3 normal = normalize(texture(texture0, uv).xyz * 2.0 - vec3(1));
	
	//float noise = random(gl_FragCoord.xy);
	float noise = randAngle();
	
	float invSamples = 1.0 / float(NUM_SAMPLES);
	int max_mip = textureQueryLevels(DepthMap) - 1;
	float perspectiveRadius = radiusWS / position.z;
	
	float occlusion = 0.0;
	float alpha = 0.5 * invSamples;
	float angle = noise;
	float angleInc = float(NUM_SPIRAL_TURNS) * invSamples * twoPI;
	for (int i = 0; i < NUM_SAMPLES; ++i) {
		alpha += invSamples;
		angle += angleInc;
		
		vec2 disk = vec2(cos(angle), sin(angle));
		float radius = perspectiveRadius * alpha;
		
		vec2 uv2 = uv + disk * radius;
		uv2 = clamp(uv2, 0.0, 1.0);
		
		// McGuire paper mip
		int mipLevel = clamp(findMSB(int(radius * 1000.0)), 0, max_mip);
		//mipLevel = max_mip;
		//mipLevel = 0;
		
		vec3 Q = getPositionVS(uv2, mipLevel);
		vec3 v = Q - position;
		
		float vv = dot(v, v);
		float vn = dot(v, normal) - bias;
		occlusion += calculateAO(vv, vn);
	}
	
	occlusion *= invSamples;
	occlusion *= intensity;
	occlusion = 1.0 - occlusion;
	occlusion = pow(occlusion, intensity);
	//occlusion *= occlusion;
	//occlusion *= occlusion;
	occlusion = clamp(occlusion, 0.0, 1.0);
	
	finalColor = vec4(vec3(occlusion), 1);
	//finalColor = vec4(normal * 0.5 + 0.5, 1);
	//finalColor = vec4(position*0.05 + 0.5,1);
	//finalColor = vec4(1);
}
