
in vec3 vertexPosition;
in vec2 vertexTexCoord;
in vec3 vertexNormal;
in vec4 vertexColor;

uniform mat4 mvp;

void vertex(){
	fragTexCoord = vertexTexCoord;
	vec4 vertex = vec4(vertexPosition, 1);
	vertex = mvp*vertex;
	gl_Position = vertex;
}

varying vec2 fragTexCoord;

uniform sampler2D texture0;
uniform vec2 u_direction;

out vec4 finalColor;

const int M = 16;

// sigma = 10
const float coeffs[M + 1] = float[M + 1](
	0.04425662519949865,
	0.044035873841196206,
	0.043380781642569775,
	0.04231065439216247,
	0.040856643282313365,
	0.039060328279673276,
	0.0369716985390341,
	0.03464682117793548,
	0.03214534135442581,
	0.0295279624870386,
	0.02685404941667096,
	0.02417948052890078,
	0.02155484948872149,
	0.019024086115486723,
	0.016623532195728208,
	0.014381474814203989,
	0.012318109844189502
);

// TODO: precompute t to avoid division

//bool between(vec2 v, vec2 bottomLeft, vec2 topRight){
//	vec2 s = step(bottomLeft, v) - step(topRight, v);
//	return bool(s.x * s.y);
//}

void fragment()
{
	vec4 sum = coeffs[0] * texture(texture0, fragTexCoord);

	for (int i = 1; i < M; i += 2)
	{
		float w0 = coeffs[i];
		float w1 = coeffs[i + 1];

		float w = w0 + w1;
		float t = w1 / w;

		vec2 forward = fragTexCoord + u_direction * (float(i) + t);
		vec2 backward = fragTexCoord - u_direction * (float(i) + t);

		//if(between(forward, vec2(0.0), vec2(1.0)))
			sum += w * texture(texture0, forward);
		//if(between(backward, vec2(0.0), vec2(1.0)))
			sum += w * texture(texture0, backward);
	}

	finalColor = sum;
}