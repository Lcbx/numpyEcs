
in vec3 vertexPosition;
in vec2 vertexTexCoord;
in vec3 vertexNormal;
in vec4 vertexColor;

uniform mat4 mvp;

void vertex(){
	fragTexCoord = vertexTexCoord;
	vec4 vertex = vec4(vertexPosition, 1);
	vertex = mvp*vertex;
	gl_Position = vertex;
}

varying vec2 fragTexCoord;

uniform mat4 invProj; // inverse proj matrix
uniform sampler2D texture0; // depth

const int NUM_SAMPLES = 8;
const float INV_NUM_SAMPLES = 1.0 / float(NUM_SAMPLES);
const float NUM_SPIRAL_TURNS = 5;

const float PI =  3.141593;
const float twoPI = 6.283186;


// could be moved to uniforms
const float radiusWS = 0.35;
const float radiusWS2 = radiusWS * radiusWS;
const float invRadius2 = 1.0 / radiusWS2;
const float bias = 0.1;
const float intensity = 25.0;

out vec4 finalColor;

float random(vec2 co) {
	return fract(dot(co.xy, vec2(3,13)) * dot(co.yx, vec2(7,4)) * 0.008);
}

float interleavedGradientNoise(vec2 co){
	return fract(52.9829189 * fract(dot(co, vec2(0.06711056, 0.00583715))));
}

bool between(vec2 v, vec2 bottomLeft, vec2 topRight){
	vec2 s = step(bottomLeft, v) - step(topRight, v);
	return bool(s.x * s.y);
}

float randAngle()
{
	ivec2 uv = ivec2(gl_FragCoord.xy);
	float angle = 0;
	angle += 30u * uv.x ^ uv.y + 10u * uv.x * uv.y;
	//angle *= interleavedGradientNoise(gl_FragCoord.xy) * PI;
	return angle;
}


vec3 getPositionVS(vec2 uv, int mip_level) {
	//float z = textureLod(texture0, uv, float(mip_level)).x; // lod level not working ?
	float z = texelFetch(texture0, ivec2(uv * textureSize(texture0, mip_level)), mip_level).x;
	vec3 clip = vec3(uv,z)*2.0 - vec3(1.0);
	vec4 view = invProj * vec4(clip, 1);
	return view.xyz / view.w;
}


// different AO formulas
float calculateAO(float vv, float vn)
{
	const float epsilon = 0.001;
	
	// (from the HPG12 paper)
	//return float(vv < radiusWS2) * max(vn / (epsilon + vv), 0.0);
	
	// default / recommended
	//float f = max(radiusWS2 - vv, 0.0) / radiusWS2;
	//return f * f * f * max(vn / (epsilon + vv), 0.0);
	
	return max(1.0 - vv * invRadius2, 0.0) * max(vn, 0.0);
	
	//return float(vv < radiusWS2) * max(vn, 0.0);
}


// TODO: apply normal or depth-aware blur (?)


void fragment() {
	
	vec2 uv = fragTexCoord * 2.0;
	
	vec3 position = getPositionVS(uv, 0);
	
	// estimate normal from depth
	vec3 dx = dFdx(position);
	vec3 dy = dFdy(position);
	vec3 normal = normalize(cross(dx, dy));
	
	float noise = randAngle();
	
	int max_mip = textureQueryLevels(texture0) - 1;
	float perspectiveRadius = radiusWS / position.z;
	
	float occlusion = 0.0;
	float alpha = 0.5 * INV_NUM_SAMPLES;
	float angle = noise;
	float angleInc = NUM_SPIRAL_TURNS * INV_NUM_SAMPLES * twoPI;
	for (int i = 0; i < NUM_SAMPLES; ++i) {
		alpha += INV_NUM_SAMPLES;
		angle += angleInc;
		
		vec2 disk = vec2(cos(angle), sin(angle));
		float radius = perspectiveRadius * alpha;
		
		vec2 uv2 = uv + disk * radius;
		
		if (between(uv2, vec2(0.0), vec2(1.0))){
			// McGuire mip
			int mipLevel = clamp(findMSB(int(radius * 200)), 0, max_mip);
			
			vec3 Q = getPositionVS(uv2, mipLevel);
			vec3 v = Q - position;
			
			float vv = dot(v, v);
			float vn = dot(v, normal) - bias;
			occlusion += calculateAO(vv, vn);
		}
	}
	occlusion *= INV_NUM_SAMPLES;
	occlusion *= intensity;
	occlusion = 1.0 - occlusion;
	//occlusion = pow(occlusion, intensity);
	occlusion *= occlusion;
	occlusion *= occlusion;
	occlusion = clamp(occlusion, 0.0, 1.0);
	
	finalColor = vec4(vec3(occlusion), 1);
}
