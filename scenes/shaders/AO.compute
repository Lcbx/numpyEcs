
in vec3 vertexPosition;
in vec2 vertexTexCoord;
in vec3 vertexNormal;
in vec4 vertexColor;

varying vec2 fragTexCoord;

uniform mat4 mvp;

void vertex() {
	fragTexCoord = vertexTexCoord;
    gl_Position = mvp * vec4(vertexPosition, 1.0);
}


uniform mat4 invView;        // inverse of the VIEW matrix used in the prepass
uniform mat4 invProj;        // inverse of the PROJECTION matrix used in the prepass
uniform sampler2D texture0;  // depth buffer from the prepass (same camera)
uniform mat4 lightView;      // light VIEW matrix
uniform mat4 lightProj;      // light PROJECTION matrix
uniform sampler2D shadowDepthMap; // light depth buffer

out vec4 finalColor;

bool between(vec2 v, vec2 bottomLeft, vec2 topRight){
	vec2 s = step(bottomLeft, v) - step(topRight, v);
	return bool(s.x * s.y);
}


void fragment() {
    const int mip_level = 0;

    vec2 uv = fragTexCoord;

    float depth = texelFetch(texture0, ivec2(uv * vec2(textureSize(texture0, mip_level))), mip_level).r;
    vec4 ndcPos = vec4(vec3(uv,depth) * 2.0 - vec3(1.0), 1.0);

    vec4 lightClip = lightProj * lightView * invView * invProj * ndcPos;
    vec3 lightFrag = lightClip.xyz / lightClip.w;
    lightFrag = lightFrag * 0.5 + 0.5;

    float shadow = -1.0;
    //shadow = depth * 0.1;

    if (between(lightFrag.xy, vec2(0.0), vec2(1.0))) {
        ivec2 shadowCoord = ivec2(lightFrag.xy * textureSize(shadowDepthMap, mip_level));
        //float occluderDepth = texelFetch(shadowDepthMap, shadowCoord, mip_level).r;
        //shadow = occluderDepth;
    	//shadow = (lightFrag.z > occluderDepth) ? 0.0 : 1.0;
    }

    finalColor = vec4(vec3(shadow), 1.0);
    //finalColor = vec4(- ndcPos.xyz, 1);
    //finalColor = vec4(-lightClip.xyz, 1);
    //finalColor = vec4(-lightFrag.xyz, 1);
}
